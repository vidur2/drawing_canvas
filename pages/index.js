import Head from 'next/head'
import { useEffect, useState } from 'react';
import styles from '../styles/Home.module.css'
import { Matrix, inverse } from "ml-matrix";

export default function Home() {
  const [dragging, setDragging] = useState(false);
  const [loadedImage, setLoadedImage] = useState(false);
  const [loadingPath, setLoadingPath] = useState(false);
  const limit = 100;

  useEffect(() => {
    let background = new Image();
    background.src = "/images/path.jpeg";

    const map = new Array();
    const canvas = document.getElementById("canvas");
    const offsetX = canvas.offsetLeft;
    const offsetY = canvas.offsetTop;
    const ctx = canvas.getContext("2d");

    const downEvent = () => {
      setDragging(true);
      ctx.beginPath()
    };

    canvas.onmousedown = downEvent;
    canvas.ontouchstart = downEvent;

    background.onload = () => {
      if (!loadedImage) {
        canvas.width = background.width;
        canvas.height = background.height;
        ctx.drawImage(background, 0, 0);
        setLoadedImage(true);
      }
    }

    const dragEvent = () => {
      setDragging(false);
      const posX_t = polyRegr(map, "t", "x");
      const posY_t = polyRegr(map, "t", "y");
      let velX_t;
      let velY_t;
      if (typeof posX_t !== "undefined" && typeof posY_t !== "undefined") {
        velX_t = powerRule(posX_t);
        velY_t = powerRule(posY_t);
      }
      const funcT_x = polyRegr(map, "x", "t");
      const funcT_y = polyRegr(map, "y", "t");
      ctx.stroke();
    };

    canvas.onmouseup = dragEvent;
    canvas.ontouchend = dragEvent;

    const moveEvent = (e) => {
      if (dragging) {
        map.push({ t: 0.1 * map.length, x: e.clientX-offsetX-(canvas.clientWidth/2), y: -(e.clientY-offsetY) + (canvas.clientHeight/2) });
        // console.log(canvas.clientWidth);
        // console.log(canvas.clientHeight);
        ctx.lineTo(e.clientX-offsetX, e.clientY-offsetY);
      }
    }

    canvas.onmousemove = moveEvent;
    canvas.ontouchmove = moveEvent;
  });

  
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={styles.main}>
        <canvas id="canvas" width="300" height="300"></canvas>
      </main>
    </div>
  )
}


function polyRegr(obj, independent, dependent) {
  const {a, b} = genArr(obj, independent, dependent);

  const matA = new Matrix(a);
  const matB = new Matrix(b);
  const matATrans = matA.transpose();
  if (matA.size > 0) {
    let final;
    try {
      final = inverse(matATrans.mmul(matA));
    } catch (_err) {
      final = inverse(matATrans.mmul(matA), true);
    }
    const func = final.mmul(matATrans).mmul(matB);

    return func;
  }
}

function genArr(obj, independent, dependednt) {
  const n = obj.length;
  const a = new Array();
  const b = new Array();

  for (let i = 0; i < n; i++) {
    const currX = obj[i];
    const tmp = new Array();

    for (let i = 0; i < n - 1; i++) {
      tmp.push(Math.pow(currX[independent], i))
    }
    a.push(tmp);

    const tmp2 = new Array();
    tmp2.push(currX[dependednt]);
    b.push(tmp2);
  }
  // console.log(b);
  return {a: a, b: b};
}

function powerRule(obj) {
  const derivative = new Array();
  for (let i = 1; i < obj.data.length; i++) {
    // console.log(obj.data[i])
    derivative.push(obj.data[i][0] * (1 + i))
  }

  return derivative;
}

