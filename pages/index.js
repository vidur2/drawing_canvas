import Head from 'next/head'
import { useEffect, useState } from 'react';
import styles from '../styles/Home.module.css'
import { Matrix, inverse } from "ml-matrix";
import {Button} from "antd";

export default function Home() {
  const [dragging, setDragging] = useState(false);
  const [loadedImage, setLoadedImage] = useState(false);
  const [counter, setCounter] = useState(0);
  const [aprilArr, setAprilArr] = useState([]);
  // const [loadingPath, setLoadingPath] = useState(false);
  const width = 16.48459999998984/2;
  const height = 8.10259999998984/2;
  const formIds = ["x", "y", "rotation", "id"];

  useEffect(() => {
    let background = new Image();
    background.src = "/images/path.jpeg";

    const map = new Array();
    const canvas = document.getElementById("canvas");
    const offsetX = canvas.offsetLeft;
    const offsetY = canvas.offsetTop;
    const ctx = canvas.getContext("2d");

    const downEvent = () => {
      setDragging(true);
      ctx.beginPath()
    };

    canvas.onmousedown = downEvent;
    canvas.ontouchstart = downEvent;

    background.onload = () => {
      if (!loadedImage) {
        canvas.width = background.width;
        canvas.height = background.height;
        ctx.drawImage(background, 0, 0);
        setLoadedImage(true);
      }
    }

    const dragEvent = () => {
      setDragging(false);
      console.log(`(${map[0].t}, ${map[0].x}, ${map[0].y})`)

      genArr(map, "t", "x");
      genArr(map, "t", "y");

      genArr(map, "x", "t");
      genArr(map, "y", "t");
    };

    canvas.onmouseup = dragEvent;
    canvas.ontouchend = dragEvent;

    const moveEvent = (e) => {
      if (dragging) {
        map.push({ t: map.length * .1, x: (e.clientX-offsetX-(canvas.clientWidth/2))/(canvas.clientWidth/2) * width, y: -((e.clientY-offsetY) - (canvas.clientHeight/2))/(canvas.clientHeight/2) * height});
        // console.log(canvas.clientWidth);
        // console.log(canvas.clientHeight);
        ctx.lineTo(e.clientX-offsetX, e.clientY-offsetY);
        ctx.stroke();
      }
    }

    canvas.onmousemove = moveEvent;
    canvas.ontouchmove = moveEvent;
  });

  const handleChange = (e) => {
    e.preventDefault();
    let [property, id] = e.target.id.split(":");
    aprilArr[id][property] = e.target.value;
    setAprilArr(aprilArr);  
    setCounter(counter + 1)
  }

  const handleAprilTag = (e) => {
    e.preventDefault();
    const aprilObj = {};
    formIds.forEach((id) => {
      const val = document.getElementById(id);
      aprilObj[id] = val.value;
      val.value = ""
    });
    aprilArr.push(aprilObj)

    fetch("http://localhost:5001/aprilPos", {
      method: "POST",
      body: JSON.stringify({
        aprilPose: aprilArr
      })
    })

    window.location.reload();
  }

  const addTag = (e) => {
    e.preventDefault();
    const aprilObj = {};

    formIds.forEach((id) => {
      const val = document.getElementById(id);
      aprilObj[id] = val.value;
      val.value = ""
    });
    aprilArr.push(aprilObj)
    setAprilArr(aprilArr)
    setCounter(counter + 1);
  }
  
  return (
    <div className={styles.container}> 
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={styles.main}>
        <table>
        <tr>
        <td>
        <canvas id="canvas" width="300" height="300"></canvas>
        </td>
        <td>
        <form onSubmit={handleAprilTag}>
        {/* <p>{counter}</p> */}
        {aprilArr.map((tag, i) => {
          return (
            <div key={i}>
            <input type="text" value={tag.x} onChange={handleChange} id={"x:" + i.toString()}></input><input type="text" value={tag.y} onChange={handleChange} id={"y:" + i} ></input>
            <p>Rotation: <input type="text" value={tag.rotation} onChange={handleChange} id={"rotation:" + i.toString()}></input></p>
            <p>Id: <input type="id" value={tag.id} onChange={handleChange} id={"id:"+i.toString()}></input></p>
            </div>
          )
        })}
        <input type="text" id="x" ></input><input type="text" id="y"></input>
        <p>Rotation: <input type="text" id="rotation"></input></p>
        <p>Id: <input type="id" id="id"></input></p>
        <p>
        <button onClick={addTag}>Add Tag</button>
        </p>
        <p>
        <button type="submit">Submit</button>
        </p>
        </form>
        </td>
        </tr>
        </table>
      </main>
    </div>
  )
}


// function polyRegr(obj, independent, dependent) {
//   const {a, b} = genArr(obj, independent, dependent);
//   const matA = new Matrix(a);
//   const matB = new Matrix(b);
//   const matATrans = matA.transpose();
//   if (matA.size > 0) {
//     let final;
//     final = inverse(matATrans.mmul(matA));

//     const func = final.mmul(matATrans).mmul(matB);

//     return func;
//   }
// }

function genArr(obj, independent, dependednt) {
  const n = obj.length;
  const a = new Array();
  const b = new Array();
  for (let i = 0; i < n; i++) {
    a.push(obj[i][independent])
    b.push(obj[i][dependednt])
  }
  try {
    fetch("/api/spline", {
      method: "POST",
      body: JSON.stringify({
        type: `${dependednt}_${independent}`,
        a, b
      })
    })
  } catch {}
}

function powerRule(obj) {
  const derivative = new Array();
  for (let i = 1; i < obj.data.length; i++) {
    // console.log(obj.data[i])
    derivative.push(obj.data[i][0] * (1 + i))
  }

  return derivative;
}

function takeInput(obj, input) {
  let out = 0;
  for (let i = 0; i < obj.data.length; i++) {
    const coeff = obj.data[i][0];
    out += coeff * Math.pow(input, i);
  }

  return out;
}

